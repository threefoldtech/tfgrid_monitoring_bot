
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>internal: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rawdaGastan/tfgrid_monitoring_bot/internal/monitor.go (51.6%)</option>
				
				<option value="file1">github.com/rawdaGastan/tfgrid_monitoring_bot/internal/parsers.go (98.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package internal

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/rs/zerolog/log"
        client "github.com/threefoldtech/substrate-client"
)

type Address string
type Network string

var (
        MainNetwork Network = "mainnet"
        TestNetwork Network = "testnet"
)

var SUBSTRATE_URLS = map[Network][]string{
        TestNetwork: {"wss://tfchain.test.grid.tf/ws"},
        MainNetwork: {"wss://tfchain.grid.tf/ws"},
}

type config struct {
        testMnemonic string
        mainMnemonic string
        tftLimit     int
        botToken     string
        chatId       string
        intervalMins int
}

type Wallets struct {
        mainnet []Address
        testnet []Address
}

type monitor struct {
        env       config
        wallets   Wallets
        substrate map[Network]client.Manager
}

// NewMonitor creates a new instance of monitor
func NewMonitor(envPath string, jsonPath string) (monitor, error) <span class="cov8" title="1">{
        mon := monitor{}

        envContent, err := readFile(envPath)
        if err != nil </span><span class="cov8" title="1">{
                return mon, err
        }</span>

        <span class="cov8" title="1">env, err := parseEnv(string(envContent))
        if err != nil </span><span class="cov8" title="1">{
                return mon, err
        }</span>

        <span class="cov8" title="1">jsonContent, err := readFile(jsonPath)
        if err != nil </span><span class="cov8" title="1">{
                return mon, err
        }</span>

        <span class="cov8" title="1">addresses, err := parseJson(jsonContent)
        if err != nil </span><span class="cov8" title="1">{
                return mon, err
        }</span>

        <span class="cov8" title="1">mon.wallets = addresses
        mon.env = env

        substrate := map[Network]client.Manager{}

        if len(mon.wallets.mainnet) != 0 </span><span class="cov8" title="1">{
                substrate[MainNetwork] = client.NewManager(SUBSTRATE_URLS[MainNetwork]...)
        }</span>
        <span class="cov8" title="1">if len(mon.wallets.testnet) != 0 </span><span class="cov8" title="1">{
                substrate[TestNetwork] = client.NewManager(SUBSTRATE_URLS[TestNetwork]...)
        }</span>

        <span class="cov8" title="1">mon.substrate = substrate

        return mon, nil</span>
}

// Start starting the monitoring service
func (m *monitor) Start() error <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Duration(m.env.intervalMins) * time.Minute)

        for range ticker.C </span><span class="cov0" title="0">{
                for network, manager := range m.substrate </span><span class="cov0" title="0">{

                        wallets := []Address{}
                        switch network </span>{
                        case MainNetwork:<span class="cov0" title="0">
                                wallets = m.wallets.mainnet</span>
                        case TestNetwork:<span class="cov0" title="0">
                                wallets = m.wallets.testnet</span>
                        }

                        <span class="cov0" title="0">for _, address := range wallets </span><span class="cov0" title="0">{
                                log.Debug().Msgf("monitoring for network %v, address %v", network, address)
                                err := m.sendMessage(manager, address)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// getTelegramUrl returns the telegram bot api url
func (m *monitor) getTelegramUrl() string <span class="cov0" title="0">{
        return fmt.Sprintf("https://api.telegram.org/bot%s", m.env.botToken)
}</span>

// sendMessage sends a message with the balance to a telegram bot
// if it is less than the tft limit
func (m *monitor) sendMessage(manager client.Manager, address Address) error <span class="cov8" title="1">{
        balance, err := m.getBalance(manager, address)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">if balance &gt;= m.env.tftLimit </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s/sendMessage", m.getTelegramUrl())
        body, _ := json.Marshal(map[string]string{
                "chat_id": m.env.chatId,
                "text":    fmt.Sprintf("account with address:\n%v\nhas balance = %v", address, balance),
        })
        response, err := http.Post(
                url,
                "application/json",
                bytes.NewBuffer(body),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if response.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return errors.New("request send message failed")
        }</span>

        <span class="cov0" title="0">defer response.Body.Close()
        return nil</span>
}

// getBalance gets the balance in TFT for the address given
func (m *monitor) getBalance(manager client.Manager, address Address) (int, error) <span class="cov8" title="1">{
        log.Debug().Msgf("get balance for %v", address)

        con, err := manager.Substrate()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">defer con.Close()

        account, err := client.FromAddress(string(address))
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov0" title="0">balance, err := con.GetBalance(account)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return int(balance.Free.Int64()), nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package internal

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "strconv"
        "strings"
)

func readFile(path string) ([]byte, error) <span class="cov8" title="1">{
        content, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return []byte{}, err
        }</span>

        <span class="cov8" title="1">return content, nil</span>
}

func parseJson(content []byte) (wallets Wallets, err error) <span class="cov8" title="1">{
        addresses := map[string][]Address{}
        err = json.Unmarshal(content, &amp;addresses)

        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">wallets = Wallets{}
        if _, ok := addresses["mainnet"]; !ok </span><span class="cov8" title="1">{
                return wallets, errors.New("mainnet addresses is missing")
        }</span> else<span class="cov8" title="1"> {
                wallets.testnet = addresses["mainnet"]
        }</span>

        <span class="cov8" title="1">if _, ok := addresses["testnet"]; !ok </span><span class="cov8" title="1">{
                return wallets, errors.New("testnet addresses is missing")
        }</span> else<span class="cov8" title="1"> {
                wallets.mainnet = addresses["testnet"]
        }</span>

        <span class="cov8" title="1">return wallets, err</span>
}

func parseEnv(content string) (config, error) <span class="cov8" title="1">{
        env := config{}

        testMnemonic := ""
        mainMnemonic := ""
        tftLimit := 0
        botToken := ""
        chatId := ""
        mins := 0

        for _, line := range strings.Split(string(content), "\n") </span><span class="cov8" title="1">{
                tokens := strings.Split(line, "=")
                if len(tokens) != 2 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">key, value := strings.TrimSpace(tokens[0]), strings.TrimSpace(tokens[1])

                switch key </span>{
                case "TESTNET_MNEMONIC":<span class="cov8" title="1">
                        testMnemonic = value</span>

                case "MAINNET_MNEMONIC":<span class="cov8" title="1">
                        mainMnemonic = value</span>

                case "TFTS_LIMIT":<span class="cov8" title="1">
                        limit, err := strconv.Atoi(value)
                        if err != nil </span><span class="cov8" title="1">{
                                return env, err
                        }</span>
                        <span class="cov8" title="1">tftLimit = limit</span>

                case "BOT_TOKEN":<span class="cov8" title="1">
                        botToken = value</span>

                case "CHAT_ID":<span class="cov8" title="1">
                        chatId = value</span>

                case "MINS":<span class="cov8" title="1">
                        intervalMins, err := strconv.Atoi(value)
                        if err != nil </span><span class="cov8" title="1">{
                                return env, err
                        }</span>
                        <span class="cov8" title="1">mins = intervalMins</span>

                default:<span class="cov8" title="1">
                        return env, fmt.Errorf("key %v is invalid", key)</span>
                }
        }

        <span class="cov8" title="1">switch </span>{
        case testMnemonic == "":<span class="cov8" title="1">
                return env, fmt.Errorf("TESTNET_MNEMONIC is missing")</span>
        case mainMnemonic == "":<span class="cov8" title="1">
                return env, fmt.Errorf("MAINNET_MNEMONIC is missing")</span>
        case tftLimit == 0:<span class="cov8" title="1">
                return env, fmt.Errorf("TFTS_LIMIT is 0")</span>
        case botToken == "":<span class="cov8" title="1">
                return env, fmt.Errorf("BOT_TOKEN is missing")</span>
        case chatId == "":<span class="cov8" title="1">
                return env, fmt.Errorf("CHAT_ID is missing")</span>
        case mins == 0:<span class="cov8" title="1">
                return env, fmt.Errorf("MINS is 0")</span>
        }

        <span class="cov8" title="1">return config{
                testMnemonic: testMnemonic,
                mainMnemonic: mainMnemonic,
                tftLimit:     tftLimit,
                botToken:     botToken,
                chatId:       chatId,
                intervalMins: mins,
        }, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
