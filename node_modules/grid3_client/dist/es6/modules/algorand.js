var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { default as AlgoSdk } from "algosdk";
import axios from "axios";
import * as PATH from "path";
import { validateInput } from "../helpers";
import { expose } from "../helpers/expose";
import { appPath, BackendStorage, StorageUpdateAction } from "../storage";
import { AlgorandAccountAssetsFromAddressModel, AlgorandAccountAssetsFromNameModel, AlgorandAccountCreateModel, AlgorandAccountDeleteModel, AlgorandAccountExistModel, AlgorandAccountGetModel, AlgorandAccountImportModel, AlgorandCreateTransactionModel, AlgorandSignBytesModel, AlgorandTransferModel, } from "./models";
class Algorand {
    constructor(config) {
        this.baseUrl = "http://node.testnet.algoexplorerapi.io/";
        this.fileName = "algorand.json";
        this.backendStorage = new BackendStorage(config.backendStorageType, config.substrateURL, config.mnemonic, config.storeSecret, config.keypairType, config.backendStorage);
    }
    save(name, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const [path, data] = yield this._load();
            if (data[name]) {
                throw Error(`A wallet with the same name ${name} already exists`);
            }
            yield this.backendStorage.update(path, name, value);
        });
    }
    _load() {
        return __awaiter(this, void 0, void 0, function* () {
            const path = PATH.join(appPath, this.fileName);
            let data = yield this.backendStorage.load(path);
            if (!data) {
                data = {};
            }
            return [path, data];
        });
    }
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            const [, data] = yield this._load();
            return Object.keys(data);
        });
    }
    exist(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.list()).includes(options.name);
        });
    }
    delete(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const [path, data] = yield this._load();
            if (!data[options.name]) {
                throw Error(`Couldn't find a wallet with name ${options.name}`);
            }
            yield this.backendStorage.update(path, options.name, "", StorageUpdateAction.delete);
            return "Deleted";
        });
    }
    create(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const account = yield AlgoSdk.generateAccount();
            const account_mnemonic = AlgoSdk.secretKeyToMnemonic(account.sk);
            yield this.save(options.name, account_mnemonic);
            return { name: options.name, address: account.addr, mnemonic: account_mnemonic };
        });
    }
    import(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const account = yield AlgoSdk.mnemonicToSecretKey(options.mnemonic);
            console.log(account);
            yield this.save(options.name, options.mnemonic);
            return { name: options.name, address: account.addr, mnemonic: options.mnemonic };
        });
    }
    assetsByName(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const account_mnemonics = yield this.get({ name: options.name });
            const account = yield AlgoSdk.mnemonicToSecretKey(account_mnemonics);
            const assets = this.assetsByAddress({ address: account.addr });
            return assets;
        });
    }
    assetsByAddress(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const assets = yield axios.get(this.baseUrl + `v2/accounts/${options.address}/`).then(res => res.data);
            return assets;
        });
    }
    get(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const [, data] = yield this._load();
            return data[options.name];
        });
    }
    sign(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const accountMnemonicsFromName = yield this.get({ name: options.name });
            const account = yield AlgoSdk.mnemonicToSecretKey(accountMnemonicsFromName);
            const signed_txn = yield AlgoSdk.signTransaction(options.txn, account.sk);
            return signed_txn;
        });
    }
    signBytes(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const accountMnemonicsFromName = yield this.get({ name: options.name });
            const account = yield AlgoSdk.mnemonicToSecretKey(accountMnemonicsFromName);
            const message = Uint8Array.from(Buffer.from(options.msg, "hex"));
            yield AlgoSdk.signBytes(message, account.sk);
            const messageSent = Buffer.from(message).toString("hex");
            return messageSent;
        });
    }
    createTransaction(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const params_fetched = yield axios.get(this.baseUrl + `v2/transactions/params`).then(res => res.data);
            console.log("transaction params fetched");
            const request_params = {
                flatFee: true,
                fee: 1000,
                firstRound: params_fetched["last-round"],
                lastRound: params_fetched["last-round"] + 1000,
                genesisID: params_fetched["genesis-id"],
                genesisHash: params_fetched["genesis-hash"],
            };
            const note = AlgoSdk.encodeObj(options.text);
            const accountMnemonics = yield this.get({ name: options.sender });
            const account = AlgoSdk.mnemonicToSecretKey(accountMnemonics);
            const txn = AlgoSdk.makePaymentTxnWithSuggestedParams(account.addr, options.receiver, options.amount, undefined, note, request_params);
            console.log("transaction binary built");
            return txn;
        });
    }
    transfer(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const txn = yield this.createTransaction({
                sender: options.sender,
                receiver: options.receiver,
                amount: options.amount,
                text: options.text,
            });
            console.log("transaction binary built", txn);
            const signedTxn = yield this.sign({ txn: txn, name: options.sender });
            console.log("transaction signed");
            const submitted_txn = yield axios.post(this.baseUrl + `v2/transactions`, signedTxn === null || signedTxn === void 0 ? void 0 : signedTxn.blob);
            return submitted_txn.data;
        });
    }
}
__decorate([
    expose,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Algorand.prototype, "list", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [AlgorandAccountExistModel]),
    __metadata("design:returntype", Promise)
], Algorand.prototype, "exist", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [AlgorandAccountDeleteModel]),
    __metadata("design:returntype", Promise)
], Algorand.prototype, "delete", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [AlgorandAccountCreateModel]),
    __metadata("design:returntype", Promise)
], Algorand.prototype, "create", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [AlgorandAccountImportModel]),
    __metadata("design:returntype", Promise)
], Algorand.prototype, "import", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [AlgorandAccountAssetsFromNameModel]),
    __metadata("design:returntype", Promise)
], Algorand.prototype, "assetsByName", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [AlgorandAccountAssetsFromAddressModel]),
    __metadata("design:returntype", Promise)
], Algorand.prototype, "assetsByAddress", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [AlgorandAccountGetModel]),
    __metadata("design:returntype", Promise)
], Algorand.prototype, "get", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [AlgorandSignBytesModel]),
    __metadata("design:returntype", Promise)
], Algorand.prototype, "signBytes", null);
__decorate([
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [AlgorandCreateTransactionModel]),
    __metadata("design:returntype", Promise)
], Algorand.prototype, "createTransaction", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [AlgorandTransferModel]),
    __metadata("design:returntype", Promise)
], Algorand.prototype, "transfer", null);
export { Algorand as algorand };
