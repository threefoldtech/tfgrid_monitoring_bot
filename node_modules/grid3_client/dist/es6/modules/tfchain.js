var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Keyring } from "@polkadot/keyring";
import axios from "axios";
import { generateMnemonic } from "bip39";
import { Buffer } from "buffer";
import MD5 from "crypto-js/md5";
import { backOff } from "exponential-backoff";
import * as PATH from "path";
import { Balance, TFClient } from "../clients";
import { expose } from "../helpers/expose";
import { validateInput } from "../helpers/validator";
import { appPath, BackendStorage, StorageUpdateAction } from "../storage/backend";
import { TfchainWalletBalanceByAddressModel, TfchainWalletBalanceByNameModel, TfchainWalletDeleteModel, TfchainWalletGetModel, TfchainWalletImportModel, TfchainWalletTransferModel, } from "./models";
class TFChain {
    constructor(config) {
        this.fileName = "tfchain.json";
        this.backendStorage = new BackendStorage(config.backendStorageType, config.substrateURL, config.mnemonic, config.storeSecret, config.keypairType);
        this.substrateURL = config.substrateURL;
        this.mnemonic = config.mnemonic;
        this.storeSecret = config.storeSecret;
        this.keypairType = config.keypairType;
        this.network = config.network;
    }
    getPath() {
        return PATH.join(appPath, this.fileName);
    }
    //loading
    _load() {
        return __awaiter(this, void 0, void 0, function* () {
            const path = this.getPath();
            let data = yield this.backendStorage.load(path);
            if (!data) {
                data = {};
            }
            return [path, data];
        });
    }
    save(name, mnemonic) {
        return __awaiter(this, void 0, void 0, function* () {
            const [path, data] = yield this._load();
            if (data[name]) {
                throw Error(`An account with the same name ${name} already exists`);
            }
            yield this.backendStorage.update(path, name, mnemonic);
        });
    }
    import(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = new TFClient(this.substrateURL, options.mnemonics, this.storeSecret, this.keypairType);
            yield client.connect();
            if (!client.isConnected()) {
                throw Error(`could not connect account with given mnemonics`);
            }
            yield this.save(options.name, client.mnemonic);
        });
    }
    getMnemonics(name) {
        return __awaiter(this, void 0, void 0, function* () {
            const [, data] = yield this._load();
            if (!data[name]) {
                throw Error(`An account with the name ${name} does not exist.`);
            }
            return data[name];
        });
    }
    get(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const mnemonics = yield this.getMnemonics(options.name);
            const client = new TFClient(this.substrateURL, mnemonics, this.storeSecret, this.keypairType);
            yield client.connect();
            return client.client.address;
        });
    }
    update(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.exist(options))) {
                throw Error(`Couldn't find an account with name ${options.name}`);
            }
            const client = new TFClient(this.substrateURL, options.mnemonics, this.storeSecret, this.keypairType);
            yield client.connect();
            try {
                const path = this.getPath();
                yield this.backendStorage.update(path, options.name, options.mnemonics, StorageUpdateAction.add);
            }
            catch (e) {
                throw Error(`could not update account mnemonics: ${e}`);
            }
        });
    }
    exist(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.list()).includes(options.name);
        });
    }
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            const [, data] = yield this._load();
            return Object.keys(data);
        });
    }
    balanceByName(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.exist(options))) {
                throw Error(`Couldn't find an account with name ${options.name}`);
            }
            const mnemonics = yield this.getMnemonics(options.name);
            const client = new TFClient(this.substrateURL, mnemonics, this.storeSecret, this.keypairType);
            const accountBalance = new Balance(client);
            return yield accountBalance.get(client.client.address);
        });
    }
    balanceByAddress(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = new TFClient(this.substrateURL, this.mnemonic, this.storeSecret, this.keypairType);
            yield client.connect();
            const accountBalance = new Balance(client);
            return yield accountBalance.get(options.address);
        });
    }
    transfer(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const mnemonics = yield this.getMnemonics(options.name);
            const sourceClient = new TFClient(this.substrateURL, mnemonics, this.storeSecret, this.keypairType);
            const accountBalance = new Balance(sourceClient);
            try {
                yield accountBalance.transfer(options.target_address, options.amount);
            }
            catch (e) {
                throw Error(`Could not complete transfer transaction: ${e}`);
            }
        });
    }
    delete(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.exist(options))) {
                throw Error(`Couldn't find an account with name ${options.name}`);
            }
            const path = this.getPath();
            yield this.backendStorage.update(path, options.name, "", StorageUpdateAction.delete);
            return "Deleted";
        });
    }
    createAccount(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield this.exist({ name: options.name })) {
                throw Error(`An account with the same name ${options.name} already exists`);
            }
            const mnemonics = generateMnemonic();
            const client = new TFClient(this.substrateURL, mnemonics, this.storeSecret, this.keypairType);
            yield client.connect();
            yield axios.post(`https://activation.${this.network}.grid.tf/activation/activate`, {
                substrateAccountID: client.client.address,
            });
            yield backOff(() => client.client.acceptTermsAndConditions("https://library.threefold.me/info/legal/#/", ""), {
                delayFirstAttempt: true,
                startingDelay: 1000,
                maxDelay: 5000,
                timeMultiple: 1.25,
            });
            const ret = yield client.twins.create(options.ip);
            yield this.import({ name: options.name, mnemonics });
            return { mnemonics, twinId: ret.id };
        });
    }
    sign(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const mnemonics = yield this.getMnemonics(options.name);
            const hash = MD5(options.message);
            const message_bytes = Uint8Array.from(Buffer.from(hash.toString(), "hex"));
            const keyr = new Keyring({ type: this.keypairType });
            const key = keyr.addFromMnemonic(mnemonics);
            const signed = key.sign(message_bytes);
            return Buffer.from(signed).toString("hex");
        });
    }
}
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [TfchainWalletImportModel]),
    __metadata("design:returntype", Promise)
], TFChain.prototype, "import", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [TfchainWalletGetModel]),
    __metadata("design:returntype", Promise)
], TFChain.prototype, "get", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [TfchainWalletImportModel]),
    __metadata("design:returntype", Promise)
], TFChain.prototype, "update", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [TfchainWalletGetModel]),
    __metadata("design:returntype", Promise)
], TFChain.prototype, "exist", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], TFChain.prototype, "list", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [TfchainWalletBalanceByNameModel]),
    __metadata("design:returntype", Promise)
], TFChain.prototype, "balanceByName", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [TfchainWalletBalanceByAddressModel]),
    __metadata("design:returntype", Promise)
], TFChain.prototype, "balanceByAddress", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [TfchainWalletTransferModel]),
    __metadata("design:returntype", Promise)
], TFChain.prototype, "transfer", null);
__decorate([
    expose,
    validateInput,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [TfchainWalletDeleteModel]),
    __metadata("design:returntype", Promise)
], TFChain.prototype, "delete", null);
export { TFChain as tfchain };
